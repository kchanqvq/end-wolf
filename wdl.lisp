(in-package #:end-wolf)

(deftype fate () '(unsigned-byte 2))

;; non inclusive
(defun max-state (max-n-pieces)
  (ash (1+ (max-wolf-index max-n-pieces)) 25))

(deftype tablebase () `(simple-array (unsigned-byte 8) (,(ash (max-state 17) -2))))

(defmacro bref (tablebase state)
  `(ldb (byte 2 (ash (ldb (byte 2 0) ,state) 1)) (aref ,tablebase (ash ,state -2))))

(setq *print-length* 1000)

(defmacro do-states ((state-var max-n-piece) (&rest bindings) &body body)
  `(let ((results nil)
         (n-seg (/ (max-state ,max-n-piece) 256))
         (channel (lparallel:make-channel)))
     (declare (state n-seg))
     (dotimes (i 256)
       (lparallel:submit-task
        channel
        (lambda (start)
          (declare (state start))
          (let ,bindings
            (dotimes (i n-seg)
              (let ((,state-var (+ start i)))
                (declare (state i ,state-var))
                ,@body))
            (or (list ,@(mapcar #'car bindings)) t)))
        (* i n-seg)))
     (unwind-protect
          (iter (for last-progress = (length results))
            (while (< last-progress 256))
            (sleep 1)
            (iter (for r = (lparallel:try-receive-result channel))
              (while r)
              (push r results))
            (unless (= last-progress (length results))
              (format t "~,2f% " (/ (* 100 (length results)) 256)))
            (finally (return results)))
       (lparallel:kill-tasks :default))))

(defun init-tablebase (tablebase)
  (format t "~&Init.~%")
  (do-states (state 17) ()
    (declare (optimize speed)
             (type tablebase tablebase))
    (let ((n-pieces (logcount (ldb (byte 25 0) state))))
      (when (= n-pieces 6)
        (when (<= (ldb (byte 10 25) state) (max-wolf-index 6))
          (setf (bref tablebase state) +wolf+))))))

(defun tablebase-summary (tablebase &optional (max-n-piece 17))
  (check-type tablebase tablebase)
  (sb-thread:barrier (:memory))
  (let* ((results
           (do-states (state max-n-piece)
               ((total 0)
                (sheep 0)
                (wolf 0)
                (unknown 0))
             (declare (optimize speed)
                      (type tablebase tablebase)
                      (type bitpos max-n-piece)
                      (type fixnum total sheep wolf unknown))
             (let ((n-pieces (logcount (ldb (byte 25 0) state))))
               (when (<= 6 n-pieces max-n-piece)
                 (when (<= (ldb (byte 10 25) state) (max-wolf-index n-pieces))
                   (case (bref tablebase state)
                     (#.+unknown+ (incf total) (incf unknown))
                     (#.+wolf+ (incf total) (incf wolf))
                     (#.+sheep+ (incf total) (incf sheep))))))))
         (results (apply #'mapcar #'+ results)))
    (destructuring-bind (total sheep wolf unknown) results
      (format t "~&total valid: ~a, invalid: ~a~%" total (- (max-state max-n-piece) total))
      (format t "sheep: ~a (~,2f%)~%" sheep (/ (* 100 sheep) total))
      (format t "wolf: ~a (~,2f%)~%" wolf (/ (* 100 wolf) total))
      (format t "unknown: ~a (~,2f%)~%" unknown (/ (* 100 unknown) total)))))

(defun tablebase-summary-1 (tablebase n-piece)
  (check-type tablebase tablebase)
  (sb-thread:barrier (:memory))
  (let* ((max-wolf-index (max-wolf-index n-piece))
         (results
           (do-states (state n-piece)
               ((total 0)
                (sheep 0)
                (wolf 0)
                (unknown 0))
             (declare (optimize speed)
                      (type tablebase tablebase)
                      (type bitpos n-piece)
                      (type (unsigned-byte 10) max-wolf-index)
                      (type fixnum total sheep wolf unknown))
             (when (= (logcount (ldb (byte 25 0) state)) n-piece)
               (when (<= (ldb (byte 10 25) state) max-wolf-index)
                 (case (bref tablebase state)
                   (#.+unknown+ (incf total) (incf unknown))
                   (#.+wolf+ (incf total) (incf wolf))
                   (#.+sheep+ (incf total) (incf sheep)))))))
         (results (apply #'mapcar #'+ results)))
    (destructuring-bind (total sheep wolf unknown) results
      (format t "~&total valid: ~a~%" total)
      (format t "sheep: ~a (~,2f%)~%" sheep (/ (* 100 sheep) total))
      (format t "wolf: ~a (~,2f%)~%" wolf (/ (* 100 wolf) total))
      (format t "unknown: ~a (~,2f%)~%" unknown (/ (* 100 unknown) total))
      unknown)))

(defun wolf-forward-scan (pair n-piece)
  (sb-thread:barrier (:memory))
  (let ((sheep (car pair))
        (wolf (cdr pair))
        (max-wolf-index (max-wolf-index n-piece)))
    (declare (type tablebase sheep wolf)
             (type bitpos n-piece)
             (type (unsigned-byte 10) max-wolf-index))
    (format t "~&Scan, wolf move, ~a pieces.~%" n-piece)
    (do-states (state n-piece) ()
      (declare (optimize speed))
      (when (= (logcount (ldb (byte 25 0) state)) n-piece)
        (when (<= (ldb (byte 10 25) state) max-wolf-index)
          (when (= (bref wolf state) +unknown+)
            (let ((fate +sheep+))
              (declare (type fate fate))
              (wolf-forward state
                            (lambda (next-state)
                              (declare (type state next-state))
                              (let ((next-fate (bref sheep next-state)))
                                (setq fate (logxor (max (logxor fate 2) (logxor next-fate 2)) 2)))))
              (setf (bref wolf state) fate))))))))

(defun sheep-forward-scan (pair n-piece)
  (sb-thread:barrier (:memory))
  (let ((sheep (car pair))
        (wolf (cdr pair))
        (max-wolf-index (max-wolf-index n-piece)))
    (declare (type tablebase sheep wolf)
             (type bitpos n-piece)
             (type (unsigned-byte 10) max-wolf-index))
    (format t "~&Scan, sheep move, ~a pieces.~%" n-piece)
    (let ((results
            (do-states (state n-piece) ((delta 0))
              (declare (optimize speed) (fixnum delta))
              (when (= (logcount (ldb (byte 25 0) state)) n-piece)
                (when (<= (ldb (byte 10 25) state) max-wolf-index)
                  (when (= (bref sheep state) +unknown+)
                    (let ((fate +wolf+))
                      (declare (type fate fate))
                      (sheep-forward state
                                     (lambda (next-state)
                                       (declare (type state next-state))
                                       (let ((next-fate (bref wolf next-state)))
                                         (setq fate (logxor (max (logxor fate 1) (logxor next-fate 1)) 1)))))
                      (when (plusp fate) (incf delta))
                      (setf (bref sheep state) fate))))))))
      (reduce #'+ results :key #'car))))

(defun wolf-forward-scan-create-worklist (pair n-piece)
  (sb-thread:barrier (:memory))
  (let ((sheep (car pair))
        (wolf (cdr pair))
        (max-wolf-index (max-wolf-index n-piece)))
    (declare (type tablebase sheep wolf)
             (type bitpos n-piece)
             (type (unsigned-byte 10) max-wolf-index))
    (format t "~&Scan create worklist, wolf move, ~a pieces.~%" n-piece)
    (let ((results
            (do-states (state n-piece) ((worklist))
              (declare (optimize speed))
              (when (= (logcount (ldb (byte 25 0) state)) n-piece)
                (when (<= (ldb (byte 10 25) state) max-wolf-index)
                  (when (= (bref wolf state) +unknown+)
                    (let ((fate +sheep+))
                      (declare (type fate fate))
                      (wolf-forward state
                                    (lambda (next-state)
                                      (declare (type state next-state))
                                      (let ((next-fate (bref sheep next-state)))
                                        (setq fate (logxor (max (logxor fate 2) (logxor next-fate 2)) 2)))))
                      (when (plusp fate)
                        (sheep-backward state
                                        (lambda (prev-state)
                                          (push prev-state worklist))))
                      (setf (bref wolf state) fate))))))))
      (sort-worklist (mapcan #'car results)))))

(defun sort-worklist (worklist)
  (setq worklist (sort worklist #'<))
  (do ((tail worklist))
      ((null (cdr tail)))
    (if (= (car tail) (cadr tail))
        (rplacd tail (cddr tail))
        (setq tail (cdr tail))))
  worklist)

(defun chop-worklist (worklist n)
  (let ((m (min 1000 (ceiling (length worklist) n)))
        (results))
    (do ((tail (cons nil worklist))
         (i 0 (1+ i)))
        ((null tail) results)
      (if (zerop (mod i m))
          (let ((next (cdr tail)))
            (push next results)
            (rplacd tail nil)
            (setq tail next))
          (setq tail (cdr tail))))))

(defmacro do-worklist ((state-var worklist) (&rest bindings) &body body)
  `(let ((results nil)
         (works (remove-if #'null (chop-worklist ,worklist 256)))
         (channel (lparallel:make-channel)))
     (dolist (w works)
       (lparallel:submit-task
        channel
        (lambda (%worklist)
          (let ,bindings
            (dolist (,state-var %worklist)
              (declare (state ,state-var))
              ,@body)
            (or (list ,@(mapcar #'car bindings)) t)))
        w))
     (unwind-protect
          (iter (for last-progress = (length results))
            (while (< last-progress (length works)))
            (sleep .2)
            (iter (for r = (lparallel:try-receive-result channel))
              (while r)
              (push r results))
            (unless (= last-progress (length results))
              (format t "~,2f% " (/ (* 100 (length results)) (length works))))
            (finally (return results)))
       (lparallel:kill-tasks :default))))

(defun sheep-forward-scan-use-worklist (pair worklist)
  (sb-thread:barrier (:memory))
  (let ((sheep (car pair))
        (wolf (cdr pair)))
    (declare (type tablebase sheep wolf))
    (format t "~&Worklist, sheep move.~%")
    (let ((results
            (do-worklist (state worklist) ((worklist))
              (declare (optimize speed))
              (when (= (bref sheep state) +unknown+)
                (let ((fate +wolf+))
                  (declare (type fate fate))
                  (sheep-forward state
                                 (lambda (next-state)
                                   (declare (type state next-state))
                                   (let ((next-fate (bref wolf next-state)))
                                     (setq fate (logxor (max (logxor fate 1) (logxor next-fate 1)) 1)))))
                  (when (plusp fate)
                    (wolf-move-backward state
                                        (lambda (prev-state)
                                          (push prev-state worklist))))
                  (setf (bref sheep state) fate))))))
      (sort-worklist (mapcan #'car results)))))

(defun wolf-forward-scan-use-worklist (pair worklist)
  (sb-thread:barrier (:memory))
  (let ((sheep (car pair))
        (wolf (cdr pair)))
    (declare (type tablebase sheep wolf))
    (format t "~&Worklist, wolf move.~%")
    (let ((results
            (do-worklist (state worklist) ((worklist))
              (declare (optimize speed))
              (let ((fate +sheep+))
                (declare (type fate fate))
                (wolf-forward state
                              (lambda (next-state)
                                (declare (type state next-state))
                                (let ((next-fate (bref sheep next-state)))
                                  (setq fate (logxor (max (logxor fate 2) (logxor next-fate 2)) 2)))))
                (when (plusp fate)
                  (sheep-backward state
                                  (lambda (prev-state)
                                    (push prev-state worklist))))
                (setf (bref wolf state) fate)))))
      (sort-worklist (mapcan #'car results)))))

(defvar *endgames*)

(defun run (n-iter n-piece)
  (assert (<= 7 n-piece 17))
  (iter (repeat n-iter)
    (wolf-forward-scan *endgames* n-piece)
    (let ((delta (sheep-forward-scan *endgames* n-piece)))
      (tablebase-summary-1 (car *endgames*) n-piece)
      (format t "~&state change: ~a~%" delta)
      (cond ((zerop delta)
             (format t "~&===Done===~%")
             (return-from run))
            ((< delta 10000000)
             (format t "~&===Switch to worklist===~%")
             (format t "use ~a worklist iterations~%" (* n-iter 10))
             (run-worklist (* n-iter 10) n-piece)
             (return-from run))))))

(defun run-worklist (n-iter n-piece)
  (assert (<= 7 n-piece 17))
  (iter (with processed = 0)
    (for i below n-iter)
    (for worklist
         initially (wolf-forward-scan-create-worklist *endgames* n-piece)
         then (wolf-forward-scan-use-worklist *endgames* worklist))
    (while worklist)
    (setq worklist (sheep-forward-scan-use-worklist *endgames* worklist))
    (let ((s (length worklist)))
      (format t "~&worklist size: ~a~%" s)
      (when (> (floor (+ s processed) 1000000)
               (floor processed 1000000))
        (tablebase-summary-1 (car *endgames*) n-piece)))
    (while worklist))
  (format t "~&===Done===~%"))

(defun load-endgames (sheep-file wolf-file)
  (unless (boundp '*endgames*)
    (setq *endgames*
          (cons (static-vectors:make-static-vector (ash (max-state 17) -2) :initial-element 0)
                (static-vectors:make-static-vector (ash (max-state 17) -2) :initial-element 0))))
  (with-open-file (in sheep-file :element-type '(unsigned-byte 8))
    (read-sequence (car *endgames*) in))
  (with-open-file (in wolf-file :element-type '(unsigned-byte 8))
    (read-sequence (cdr *endgames*) in)))

(defun save-endgames (sheep-file wolf-file)
  (with-open-file (out sheep-file :direction :output :element-type '(unsigned-byte 8))
    (write-sequence (car *endgames*) out))
  (with-open-file (out wolf-file :direction :output :element-type '(unsigned-byte 8))
    (write-sequence (cdr *endgames*) out)))

(defun unload-endgames ()
  (let ((e *endgames*))
    (makunbound '*endgames*)
    (static-vectors:free-static-vector (car e))
    (setf (car e) nil)
    (static-vectors:free-static-vector (cdr e))
    (setf (cdr e) nil)))

#+nil (progn
        (static-vectors:free-static-vector (car *endgames*))
        (static-vectors:free-static-vector (cdr *endgames*))
        (makunbound '*endgames*))

#+nil (with-open-file (out "~/playground/wolf-chess-init.bin" :direction :output :element-type '(unsigned-byte 8))
        (write-sequence (car *endgames*) out))


#+nil (load-endgames "~/playground/wolf-chess-10s.bin" "~/playground/wolf-chess-10w.bin")

#+nil (progn
        (with-open-file (out "~/playground/wolf-chess-10s.bin" :direction :output :element-type '(unsigned-byte 8))
          (write-sequence (car *endgames*) out))
        (with-open-file (out "~/playground/wolf-chess-10w.bin" :direction :output :element-type '(unsigned-byte 8))
          (write-sequence (cdr *endgames*) out)))

#+nil (init-tablebase *endgames*)
