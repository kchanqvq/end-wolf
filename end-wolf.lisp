(uiop:define-package #:end-wolf
  (:use #:cl #:iterate #:alexandria))

(in-package #:end-wolf)

(declaim (type (simple-array (unsigned-byte 10) (18 4)) *binomial-table*)
         (inline encode-set decode-set
                 reencode-wolf-index decode-wolf-index max-wolf-index))

(deftype state () '(unsigned-byte 35))
(deftype board () '(unsigned-byte 25))
(deftype bitpos () '(unsigned-byte 5))

(sb-ext:defglobal *binomial-table*
    (let ((table (make-array '(18 4) :initial-element 0 :element-type '(unsigned-byte 10))))
      (loop for n from 0 to 17 do
        (setf (aref table n 0) 1)
        (loop for k from 1 to (min n 3) do
          (setf (aref table n k)
                (+ (aref table (1- n) (1- k))
                   (aref table (1- n) k)))))
      table))

(defun encode-set (a b c)
  (declare (optimize speed) (type (unsigned-byte 5) a b c))
  (+ a (aref *binomial-table* b 2) (aref *binomial-table* c 3)))

(defun decode-set (index)
  (declare (optimize speed) (type (unsigned-byte 10) index))
  (let* ((n3 (loop for n from 17 downto 0
                   if (<= (aref *binomial-table* n 3) index) return n))
         (rem3 (- index (aref *binomial-table* n3 3)))

         (n2 (loop for n from (1- n3) downto 0
                   if (<= (aref *binomial-table* n 2) rem3) return n))
         (rem2 (- rem3 (aref *binomial-table* n2 2)))

         (n1 (loop for n from (1- n2) downto 0
                   if (<= n rem2) return n)))
    (values n1 n2 n3)))

(defun reencode-wolf-index (mask state)
  (declare (optimize speed)
           (type board mask)
           (type state state))
  (let ((a 0) (b 0) (c 0))
    (declare (type bitpos a b c))
    (let* ((low-bit (logand mask (- mask)))
           (idx (logcount (logand state (1- low-bit)))))
      (setq a idx mask (logxor mask low-bit)))
    (let* ((low-bit (logand mask (- mask)))
           (idx (logcount (logand state (1- low-bit)))))
      (setq b idx mask (logxor mask low-bit)))
    (let* ((low-bit (logand mask (- mask)))
           (idx (logcount (logand state (1- low-bit)))))
      (setq c idx mask (logxor mask low-bit)))
    (setf (ldb (byte 10 25) state) (encode-set a b c))
    state))

(defun decode-wolf-index (state)
  (declare (optimize speed)
           (type state state))
  (multiple-value-bind (a b c) (decode-set (ldb (byte 10 25) state))
    (let ((mask 0) (count 0))
      (declare (type board mask)
               (type bitpos count))
      (flet ((find-next (target)
               (loop while (< count target) do
                 (setf state (logand state (1- state))) ; Clear lowest bit
                 (incf count))
               (let ((low-bit (logand state (- state))))
                 (setf mask (logior mask low-bit)))))
        (find-next a)
        (find-next b)
        (find-next c)
        mask))))

;; inclusive
(defun max-wolf-index (max-n-pieces)
  (encode-set (- max-n-pieces 3) (- max-n-pieces 2) (- max-n-pieces 1)))

(defun encode-state (list)
  (let ((state 0)
        (logcount 0)
        (ws nil)
        (i 0))
    (dolist (row list)
      (dolist (piece row)
        (ecase piece
          (w (push logcount ws)
           (setf (ldb (byte 1 i) state) 1)
           (incf logcount))
          (s (setf (ldb (byte 1 i) state) 1)
           (incf logcount))
          (-))
        (incf i)))
    (setf (ldb (byte 10 25) state) (apply #'encode-set (reverse ws)))
    state))

(defun decode-state (state)
  (let ((wm (decode-wolf-index state)))
    (iter (with bitpos = 0)
      (for i below 5)
      (collecting
        (iter (for j below 5)
          (if (plusp (ldb (byte 1 bitpos) state))
              (collect (if (plusp (ldb (byte 1 bitpos) wm))
                           'w 's))
              (collect '-))
          (incf bitpos))))))

(defun print-state (state)
  (format t "~{~{~a~^ ~}~%~}~%"(decode-state state)))

(defun fuzz-encode-decode (seed)
  (let ((*random-state* (sb-ext:seed-random-state seed)))
    (iter (with n = 0)
      (repeat 100000)
      (for wc = 0)
      (for sc = 0)
      (for state = (iter
                     (for i below 5)
                     (collecting
                       (iter (for j below 5)
                         (collecting
                           (case (random 5)
                             ((0 1) '-)
                             ((2 3) (if (< sc 15)
                                        (prog1 's (incf sc))
                                        '-))
                             (4 (if (< wc 3)
                                    (prog1 'w (incf wc))
                                    '-))))))))
      (unless (< wc 3)
        (incf n)
        (let ((encoded (encode-state state)))
          (unless (equal state (decode-state encoded))
            (error "state ~a" state))
          (unless (= encoded (reencode-wolf-index (decode-wolf-index encoded) encoded))
            (error "wolf index ~a" state))))
      (finally (return n)))))

(declaim (inline sheep-forward wolf-forward
                 sheep-backward wolf-move-backward))

(defun sheep-forward (state cont)
  (declare (optimize speed)
           (type state state)
           (type function cont))
  (let ((wm (decode-wolf-index state))
        (bitpos 0))
    (declare (type bitpos bitpos))
    (dotimes (i 5)
      (dotimes (j 5)
        (when (plusp (ldb (byte 1 bitpos) state))
          (unless (plusp (ldb (byte 1 bitpos) wm))
            (let ((new-state state))
              (setf (ldb (byte 1 bitpos) new-state) 0)
              (macrolet ((consider-move (skip-reencode test pos)
                           `(when ,test
                              (when (zerop (ldb (byte 1 ,pos) state))
                                (let ((new-state new-state))
                                  (setf (ldb (byte 1 ,pos) new-state) 1)
                                  ,(if skip-reencode
                                       '(funcall cont new-state)
                                       '(funcall cont (reencode-wolf-index wm new-state))))))))
                (consider-move t (> j 0) (- bitpos 1))
                (consider-move t (< j 4) (+ bitpos 1))
                (consider-move nil (> i 0) (- bitpos 5))
                (consider-move nil (< i 4) (+ bitpos 5))))))
        (incf bitpos)))))
(defun sheep-backward (state cont)
  (sheep-forward state cont))

(defun wolf-forward (state cont)
  (declare (optimize speed)
           (type state state)
           (type function cont))
  (let ((wm (decode-wolf-index state)))
    (macrolet ((consider-move (skip-move-reencode move-test move-pos cap-test cap-pos)
                 `(when ,move-test
                    (when (zerop (ldb (byte 1 ,move-pos) state))
                      (let ((new-state new-state))
                        (setf (ldb (byte 1 ,move-pos) new-state) 1)
                        ,(if skip-move-reencode
                             '(funcall cont new-state)
                             `(let ((new-wm new-wm))
                                (setf (ldb (byte 1 ,move-pos) new-wm) 1)
                                (funcall cont (reencode-wolf-index new-wm new-state)))))
                      (when ,cap-test
                        (when (and (plusp (ldb (byte 1 ,cap-pos) state))
                                   (zerop (ldb (byte 1 ,cap-pos) wm)))
                          (let ((new-wm new-wm))
                            (setf (ldb (byte 1 ,cap-pos) new-wm) 1)
                            (funcall cont (reencode-wolf-index new-wm new-state)))))))))
      (let ((next-wm wm))
        (iter (repeat 3)
          (let ((new-state state)
                (new-wm wm)
                (bitpos (1- (integer-length next-wm))))
            (declare (type bitpos bitpos))
            (setf (ldb (byte 1 bitpos) new-state) 0
                  (ldb (byte 1 bitpos) new-wm) 0
                  (ldb (byte 1 bitpos) next-wm) 0)
            (multiple-value-bind (i j) (floor bitpos 5)
              (consider-move t (> j 0) (- bitpos 1) (> j 1) (- bitpos 2))
              (consider-move t (< j 4) (+ bitpos 1) (< j 3) (+ bitpos 2))
              (consider-move nil (> i 0) (- bitpos 5) (> i 1) (- bitpos 10))
              (consider-move nil (< i 4) (+ bitpos 5) (< i 3) (+ bitpos 10)))))))))

(defconstant +unknown+ 0)
(defconstant +wolf+ 1)
(defconstant +sheep+ 2)

(deftype fate () '(unsigned-byte 2))

;; non inclusive
(defun max-state (max-n-pieces)
  (ash (1+ (max-wolf-index max-n-pieces)) 25))

(deftype tablebase () `(simple-array (unsigned-byte 8) (,(ash (max-state 17) -2))))

(defmacro bref (tablebase state)
  `(ldb (byte 2 (ash (ldb (byte 2 0) ,state) 1)) (aref ,tablebase (ash ,state -2))))

(setq *print-length* 1000)

(defmacro do-states ((state-var max-n-piece) (&rest bindings) &body body)
  `(let ((results nil)
         (n-seg (/ (max-state ,max-n-piece) 256))
         (channel (lparallel:make-channel)))
     (declare (state n-seg))
     (dotimes (i 256)
       (lparallel:submit-task
        channel
        (lambda (start)
          (declare (state start))
          (let ,bindings
            (dotimes (i n-seg)
              (let ((,state-var (+ start i)))
                (declare (state i ,state-var))
                ,@body))
            (or (list ,@(mapcar #'car bindings)) t)))
        (* i n-seg)))
     (unwind-protect
          (iter (for last-progress = (length results))
            (while (< last-progress 256))
            (sleep .1)
            (iter (for r = (lparallel:try-receive-result channel))
              (while r)
              (push r results))
            (unless (= last-progress (length results))
              (format t "~,2f% " (/ (* 100 (length results)) 256)))
            (finally (return results)))
       (lparallel:kill-tasks :default))))

(defun init-tablebase (tablebase)
  (format t "~&Init.~%")
  (do-states (state 17) ()
    (declare (optimize speed)
             (type tablebase tablebase))
    (let ((n-pieces (logcount (ldb (byte 25 0) state))))
      (when (= n-pieces 6)
        (when (<= (ldb (byte 10 25) state) (max-wolf-index 6))
          (setf (bref tablebase state) +wolf+))))))

(defun tablebase-summary (tablebase &optional (max-n-piece 17))
  (check-type tablebase tablebase)
  (sb-thread:barrier (:memory))
  (let* ((results
           (do-states (state max-n-piece)
               ((total 0)
                (sheep 0)
                (wolf 0)
                (unknown 0))
             (declare (optimize speed)
                      (type tablebase tablebase)
                      (type bitpos max-n-piece)
                      (type fixnum total sheep wolf unknown))
             (let ((n-pieces (logcount (ldb (byte 25 0) state))))
               (when (<= 6 n-pieces max-n-piece)
                 (when (<= (ldb (byte 10 25) state) (max-wolf-index n-pieces))
                   (case (bref tablebase state)
                     (#.+unknown+ (incf total) (incf unknown))
                     (#.+wolf+ (incf total) (incf wolf))
                     (#.+sheep+ (incf total) (incf sheep))))))))
         (results (apply #'mapcar #'+ results)))
    (destructuring-bind (total sheep wolf unknown) results
      (format t "~&total valid: ~a, invalid: ~a~%" total (- (max-state max-n-piece) total))
      (format t "sheep: ~a (~,2f%)~%" sheep (/ (* 100 sheep) total))
      (format t "wolf: ~a (~,2f%)~%" wolf (/ (* 100 wolf) total))
      (format t "unknown: ~a (~,2f%)~%" unknown (/ (* 100 unknown) total)))))

(defun tablebase-summary-1 (tablebase n-piece)
  (check-type tablebase tablebase)
  (sb-thread:barrier (:memory))
  (let* ((max-wolf-index (max-wolf-index n-piece))
         (results
           (do-states (state n-piece)
               ((total 0)
                (sheep 0)
                (wolf 0)
                (unknown 0))
             (declare (optimize speed)
                      (type tablebase tablebase)
                      (type bitpos n-piece)
                      (type (unsigned-byte 10) max-wolf-index)
                      (type fixnum total sheep wolf unknown))
             (when (= (logcount (ldb (byte 25 0) state)) n-piece)
               (when (<= (ldb (byte 10 25) state) max-wolf-index)
                 (case (bref tablebase state)
                   (#.+unknown+ (incf total) (incf unknown))
                   (#.+wolf+ (incf total) (incf wolf))
                   (#.+sheep+ (incf total) (incf sheep)))))))
         (results (apply #'mapcar #'+ results)))
    (destructuring-bind (total sheep wolf unknown) results
      (format t "~&total valid: ~a~%" total)
      (format t "sheep: ~a (~,2f%)~%" sheep (/ (* 100 sheep) total))
      (format t "wolf: ~a (~,2f%)~%" wolf (/ (* 100 wolf) total))
      (format t "unknown: ~a (~,2f%)~%" unknown (/ (* 100 unknown) total))
      unknown)))

(defun forward (pair n-piece)
  (let ((sheep (car pair))
        (wolf (cdr pair))
        (max-wolf-index (max-wolf-index n-piece)))
    (declare (type tablebase sheep wolf)
             (type bitpos n-piece)
             (type (unsigned-byte 10) max-wolf-index))
    (format t "~&Wolf move, ~a pieces.~%" n-piece)
    (sb-thread:barrier (:memory))
    (do-states (state n-piece) ()
      (declare (optimize speed))
      (when (= (logcount (ldb (byte 25 0) state)) n-piece)
        (when (<= (ldb (byte 10 25) state) max-wolf-index)
          (when (= (bref wolf state) +unknown+)
            (let ((fate +sheep+))
              (declare (type fate fate))
              (wolf-forward state
                            (lambda (next-state)
                              (declare (type state next-state))
                              (let ((next-fate (bref sheep next-state)))
                                (setq fate (logxor (max (logxor fate 2) (logxor next-fate 2)) 2)))))
              (setf (bref wolf state) fate))))))
    (format t "~&Sheep move, ~a pieces.~%" n-piece)
    (sb-thread:barrier (:memory))
    (let ((results
            (do-states (state n-piece)
                ((delta-sheep 0) (delta-wolf 0))
              (declare (optimize speed) (fixnum delta-sheep delta-wolf))
              (when (= (logcount (ldb (byte 25 0) state)) n-piece)
                (when (<= (ldb (byte 10 25) state) max-wolf-index)
                  (when (= (bref sheep state) +unknown+)
                    (let ((fate +wolf+))
                      (declare (type fate fate))
                      (sheep-forward state
                                     (lambda (next-state)
                                       (declare (type state next-state))
                                       (let ((next-fate (bref wolf next-state)))
                                         (setq fate (logxor (max (logxor fate 1) (logxor next-fate 1)) 1)))))
                      (case fate
                        (#.+sheep+
                         (incf delta-sheep)
                         (setf (bref sheep state) +sheep+))
                        (#.+wolf+ (incf delta-wolf)
                         (setf (bref sheep state) +wolf+))))))))))
      (apply #'mapcar #'+ results))))

(defvar *endgames*)

(defun run (n-iter n-piece)
  (assert (<= 7 n-piece 17))
  (iter (repeat n-iter)
    (destructuring-bind (delta-sheep delta-wolf) (forward *endgames* n-piece)
      (when (and (zerop delta-wolf) (zerop delta-sheep))
        (format t "~&===Done===~%")
        (return))))
  (tablebase-summary-1 (car *endgames*) n-piece))

(defun load-endgames (sheep-file wolf-file)
  (unless (boundp '*endgames*)
    (setq *endgames*
          (cons (static-vectors:make-static-vector (ash (max-state 17) -2) :initial-element 0)
                (static-vectors:make-static-vector (ash (max-state 17) -2) :initial-element 0))))
  (with-open-file (in sheep-file :element-type '(unsigned-byte 8))
    (read-sequence (car *endgames*) in))
  (with-open-file (in wolf-file :element-type '(unsigned-byte 8))
    (read-sequence (cdr *endgames*) in)))

(defun save-endgames (sheep-file wolf-file)
  (with-open-file (out sheep-file :direction :output :element-type '(unsigned-byte 8))
    (write-sequence (car *endgames*) out))
  (with-open-file (out wolf-file :direction :output :element-type '(unsigned-byte 8))
    (write-sequence (cdr *endgames*) out)))

(defun unload-endgames ()
  (let ((e *endgames*))
    (makunbound '*endgames*)
    (static-vectors:free-static-vector (car e))
    (setf (car e) nil)
    (static-vectors:free-static-vector (cdr e))
    (setf (cdr e) nil)))

#+nil (progn
        (static-vectors:free-static-vector (car *endgames*))
        (static-vectors:free-static-vector (cdr *endgames*))
        (makunbound '*endgames*))

#+nil (with-open-file (out "~/playground/wolf-chess-init.bin" :direction :output :element-type '(unsigned-byte 8))
        (write-sequence (car *endgames*) out))


#+nil (load-endgames "~/playground/wolf-chess-10s.bin" "~/playground/wolf-chess-10w.bin")

#+nil (progn
  (with-open-file (out "~/playground/wolf-chess-10s.bin" :direction :output :element-type '(unsigned-byte 8))
    (write-sequence (car *endgames*) out))
  (with-open-file (out "~/playground/wolf-chess-10w.bin" :direction :output :element-type '(unsigned-byte 8))
    (write-sequence (cdr *endgames*) out)))

#+nil (init-tablebase *endgames*)
