(in-package #:end-wolf)

(deftype fate () '(signed-byte 16))

(defconstant +wolf-m1+ (1- (ash 1 15)))
(defconstant +sheep-m1+ (- (ash 1 15)))

(defvar *worklist-threshold* 0.1)
(defvar *worklist-limit* 10000000)

(defvar *n-tasks* 64)

(deftype tablebase () `(simple-array fate (*)))

(defvar *endgames* (make-array 18 :initial-contents (iter (repeat 18) (collect (cons nil nil)))))

(setq *print-length* 1000)

(defmacro do-states ((state-var sheep-mask-var wolf-mask-var n-piece)
                     (&rest bindings) &body body)
  `(let* ((%n-piece ,n-piece)
          (max-state (max-state %n-piece))
          (n-seg (ceiling max-state *n-tasks*)))
     (declare (state n-seg) (bitpos %n-piece))
     (lparallel:pmapcar
      (lambda (%start %end)
        (let ,bindings
          (multiple-value-bind (,sheep-mask-var ,wolf-mask-var)
              (decode-mask %start ,n-piece)
            (declare (optimize speed)
                     (state %start %end)
                     (board ,sheep-mask-var ,wolf-mask-var))
            (loop for ,state-var of-type state from %start below %end
                  do (locally ,@body)
                  do (setf (values ,sheep-mask-var ,wolf-mask-var)
                           (next-mask ,sheep-mask-var ,wolf-mask-var ,n-piece))))
          (write-char #\.)
          (list ,@(mapcar #'car bindings))))
      :parts *n-tasks*
      (iota *n-tasks* :step n-seg)
      (mapcar (curry #'min max-state) (iota *n-tasks* :start n-seg :step n-seg)))))

(defun summary (n-piece &optional (to-move 's))
  (sb-thread:barrier (:memory))
  (format t "~&Computing summary.~%")
  (let* ((tablebase (or (ecase to-move
                          (s (car (aref *endgames* n-piece)))
                          (w (cdr (aref *endgames* n-piece))))
                        (progn
                          (format t "Table not loaded.~%")
                          (return-from summary))))
         (results
           (do-states (state sm wm n-piece)
               ((total 0)
                (sheep 0)
                (sheep-m-max 0)
                (wolf 0)
                (wolf-m-max 0)
                (unknown 0))
             (declare (tablebase tablebase)
                      (fixnum total sheep wolf unknown sheep-m-max wolf-m-max))
             (let ((fate (aref tablebase state)))
               (case (signum fate)
                 (1 (incf total) (incf wolf)
                  (setq wolf-m-max (max wolf-m-max (1+ (- +wolf-m1+ fate)))))
                 (0 (incf total) (incf unknown))
                 (-1 (incf total) (incf sheep)
                  (setq sheep-m-max (max sheep-m-max (1+ (- fate +sheep-m1+)))))))))
         (total (reduce #'+ results :key #'first))
         (sheep (reduce #'+ results :key #'second))
         (sheep-m-max (reduce #'max results :key #'third))
         (wolf (reduce #'+ results :key #'fourth))
         (wolf-m-max (reduce #'max results :key #'fifth))
         (unknown (reduce #'+ results :key #'sixth)))
    (format t "~&total valid: ~a~%" total)
    (format t "sheep: ~a (~,2f%), max mate in ~a~%" sheep (/ (* 100 sheep) total) sheep-m-max)
    (format t "wolf: ~a (~,2f%), max mate in ~a~%" wolf (/ (* 100 wolf) total) wolf-m-max)
    (format t "unknown: ~a (~,2f%)~%" unknown (/ (* 100 unknown) total))
    unknown))

(defmacro wolf-updater (fate-var sheep-var n-piece)
  `(lambda (next-sm next-wm)
     (let ((next-fate (aref ,sheep-var (encode-mask next-sm next-wm ,n-piece))))
       (setq ,fate-var (max ,fate-var (if (> next-fate 1) (1- next-fate) next-fate))))))

(defun wolf-forward-scan (sheep wolf prev-sheep n-piece)
  (declare (tablebase sheep wolf prev-sheep))
  (sb-thread:barrier (:memory))
  (assert (= (length sheep) (length wolf) (max-state n-piece)))
  (assert (= (length prev-sheep) (max-state (1- n-piece))))
  (format t "~&Scan, ~a pieces wolf-to-move.~%" n-piece)
  (do-states (state sm wm n-piece) ()
    (when (zerop (aref wolf state))
      (let ((fate +sheep-m1+))
        (declare (fate fate))
        (wolf-forward sm wm
                      (wolf-updater fate sheep n-piece)
                      (wolf-updater fate prev-sheep (1- n-piece)))
        (setf (aref wolf state) fate)))))

(defmacro sheep-updater (fate-var wolf-var n-piece)
  `(lambda (next-sm next-wm)
     (let ((next-fate (aref ,wolf-var (encode-mask next-sm next-wm ,n-piece))))
       (setq ,fate-var (min ,fate-var (if (< next-fate -1) (1+ next-fate) next-fate))))))

(defun sheep-forward-scan (sheep wolf n-piece)
  (declare (tablebase sheep wolf))
  (sb-thread:barrier (:memory))
  (assert (= (length sheep) (length wolf) (max-state n-piece)))
  (format t "~&Scan, ~a pieces sheep-to-move.~%" n-piece)
  (let ((results
          (do-states (state sm wm n-piece) ((delta 0))
            (declare (fixnum delta))
            (when (zerop (aref sheep state))
              (let ((fate +wolf-m1+))
                (declare (fate fate))
                (sheep-forward sm wm (sheep-updater fate wolf n-piece))
                (unless (zerop fate) (incf delta))
                (setf (aref sheep state) fate))))))
    (reduce #'+ results :key #'car)))

(defmacro work-pusher (worklist-var table-var n-piece)
  `(lambda (prev-sm prev-wm)
     (when (zerop (aref ,table-var (encode-mask prev-sm prev-wm ,n-piece)))
       (push (logior (ash prev-sm 25) prev-wm) ,worklist-var))))

(defun wolf-forward-scan-create-worklist (sheep wolf prev-sheep n-piece)
  (declare (tablebase sheep wolf prev-sheep))
  (sb-thread:barrier (:memory))
  (assert (= (length sheep) (length wolf) (max-state n-piece)))
  (format t "~&Scan create worklist, ~a pieces wolf-to-move.~%" n-piece)
  (let ((results
          (do-states (state sm wm n-piece) ((worklist))
            (when (zerop (aref wolf state))
              (let ((fate +sheep-m1+))
                (declare (fate fate))
                (wolf-forward sm wm
                              (wolf-updater fate sheep n-piece)
                              (wolf-updater fate prev-sheep (1- n-piece)))
                (unless (zerop fate)
                  (sheep-backward sm wm (work-pusher worklist sheep n-piece)))
                (setf (aref wolf state) fate))))))
    (sort-worklist (mapcan #'car results) n-piece)))

(defun parallel-sort (list n-piece)
  (let ((segments (mapcar (lambda (l)
                            (lparallel:future
                              (declare (optimize speed (space 0)) (list l))
                              (sort l #'< :key
                                    (lambda (w)
                                      (declare ((unsigned-byte 50) w))
                                      (encode-mask (ldb (byte 25 25) w) (ldb (byte 25 0) w)
                                                   n-piece)))))
                          (chop-worklist list 8))))
    (if (cdr segments)
        (lparallel:force
         (reduce (lambda (a b)
                   (lparallel:future
                     (merge 'list (lparallel:force a) (lparallel:force b) #'<)))
                 segments))
        (lparallel:force (car segments)))))

(defun sort-worklist (worklist n-piece)
  (setq worklist (parallel-sort worklist n-piece))
  (do ((tail worklist))
      ((null (cdr tail)))
    (if (= (car tail) (cadr tail))
        (rplacd tail (cddr tail))
        (setq tail (cdr tail))))
  worklist)

(defun chop-worklist (worklist n)
  (let ((m (max 1000 (ceiling (length worklist) n)))
        (results))
    (do ((tail (cons nil worklist))
         (i 0 (1+ i)))
        ((null tail) (remove-if #'null results))
      (if (zerop (mod i m))
          (let ((next (cdr tail)))
            (push next results)
            (rplacd tail nil)
            (setq tail next))
          (setq tail (cdr tail))))))

(defmacro do-worklist ((state-var sheep-mask-var wolf-mask-var worklist n-piece)
                       (&rest bindings) &body body)
  `(let ((%n-piece ,n-piece)
         (works (chop-worklist ,worklist *n-tasks*)))
     (lparallel:pmapcar
      (lambda (works)
        (let ,bindings
          (declare (optimize speed) (bitpos %n-piece))
          (dolist (w works)
            (declare ((unsigned-byte 50) w))
            (let* ((,sheep-mask-var (ldb (byte 25 25) w))
                   (,wolf-mask-var (ldb (byte 25 0) w))
                   (,state-var (encode-mask ,sheep-mask-var ,wolf-mask-var %n-piece)))
              (declare (board ,sheep-mask-var ,wolf-mask-var))
              ,@body))
          (write-char #\.)
          (force-output)
          (list ,@(mapcar #'car bindings))))
      :parts (length works)
      works)))

(defun sheep-forward-scan-use-worklist (sheep wolf worklist n-piece)
  (declare (tablebase sheep wolf))
  (sb-thread:barrier (:memory))
  (format t "~&Worklist, ~a pieces sheep-to-move.~%" n-piece)
  (let ((results
          (do-worklist (state sm wm worklist n-piece) ((worklist))
            (let ((fate +wolf-m1+))
              (declare (fate fate))
              (sheep-forward sm wm (sheep-updater fate wolf n-piece))
              (unless (zerop fate)
                (wolf-move-backward sm wm (work-pusher worklist wolf n-piece)))
              (setf (aref sheep state) fate)))))
    (sort-worklist (mapcan #'car results) n-piece)))

(defun wolf-forward-scan-use-worklist (sheep wolf prev-sheep worklist n-piece)
  (declare (tablebase sheep wolf prev-sheep))
  (sb-thread:barrier (:memory))
  (format t "~&Worklist, ~a pieces wolf-to-move.~%" n-piece)
  (let ((results
          (do-worklist (state sm wm worklist n-piece) ((worklist))
            (let ((fate +sheep-m1+))
              (declare (fate fate))
              (wolf-forward sm wm
                            (wolf-updater fate sheep n-piece)
                            (wolf-updater fate prev-sheep (1- n-piece)))
              (unless (zerop fate)
                (sheep-backward sm wm (work-pusher worklist sheep n-piece)))
              (setf (aref wolf state) fate)))))
    (sort-worklist (mapcan #'car results) n-piece)))

(defun init (n-piece)
  (unless (car (aref *endgames* n-piece))
    (format t "Allocating ~a pieces sheep-to-move table~%" n-piece)
    (setf (car (aref *endgames* n-piece))
          (static-vectors:make-static-vector (max-state n-piece)
                                             :initial-element 0
                                             :element-type 'fate)))
  (unless (cdr (aref *endgames* n-piece))
    (format t "Allocating ~a pieces wolf-to-move table~%" n-piece)
    (setf (cdr (aref *endgames* n-piece))
          (static-vectors:make-static-vector (max-state n-piece)
                                             :initial-element 0
                                             :element-type 'fate))))

(defun run (n-piece)
  (assert (<= 7 n-piece 17))
  (when (and (= n-piece 7) (not (car (aref *endgames* 6))))
    (format t "Filling 6 pieces sheep-to-move table.")
    (setf (car (aref *endgames* 6))
          (static-vectors:make-static-vector (max-state 6)
                                             :initial-element +wolf-m1+
                                             :element-type 'fate)))
  (unless (car (aref *endgames* (1- n-piece)))
    (error "~a pieces sheep-to-move table not available." (1- n-piece)))
  (init n-piece)
  (iter (with sheep = (car (aref *endgames* n-piece)))
    (with wolf = (cdr (aref *endgames* n-piece)))
    (with prev-sheep = (car (aref *endgames* (1- n-piece))))
    (wolf-forward-scan sheep wolf prev-sheep n-piece)
    (let* ((delta (sheep-forward-scan sheep wolf n-piece))
           (unknown (summary n-piece)))
      (format t "~&state change: ~a~%" delta)
      (cond ((zerop delta)
             (format t "~&===Done===~%")
             (summary n-piece)
             (return-from run))
            ((and (< (/ delta unknown) *worklist-threshold*)
                  (< delta *worklist-limit*))
             (format t "~&===Switch to worklist===~%")
             (run-worklist n-piece)
             (return-from run))))))

(defun run-worklist (n-piece)
  (assert (<= 7 n-piece 17))
  (iter (with sheep = (car (aref *endgames* n-piece)))
    (with wolf = (cdr (aref *endgames* n-piece)))
    (with prev-sheep = (car (aref *endgames* (1- n-piece))))
    (with processed = 0)
    (for worklist
         initially (wolf-forward-scan-create-worklist sheep wolf prev-sheep n-piece)
         then (wolf-forward-scan-use-worklist sheep wolf prev-sheep worklist n-piece))
    (while worklist)
    (setq worklist (sheep-forward-scan-use-worklist sheep wolf worklist n-piece))
    (let ((s (length worklist)))
      (format t "~&worklist size: ~a~%" s)
      (when (> (floor (+ s processed) 1000000)
               (floor processed 1000000))
        (summary n-piece)))
    (while worklist))
  (format t "~&===Done===~%")
  (summary n-piece))

(defun run-all (directory-path &optional (max-n-piece 17))
  (setq directory-path (uiop:ensure-directory-pathname directory-path))
  (iter (for n-piece from 7 to max-n-piece)
    (run n-piece)
    (save-endgames n-piece
                   (make-pathname :name (format nil "wolf-dtm-~as" n-piece)
                                  :type "bin" :defaults directory-path)
                   (make-pathname :name (format nil "wolf-dtm-~aw" n-piece)
                                  :type "bin" :defaults directory-path))
    (when (> n-piece 7)
      (unload-endgames (1- n-piece))))
  (unload-endgames))

(defun load-endgames (n-piece sheep-file wolf-file)
  (format t "Reading ~a pieces sheep-to-move from ~a.~%" n-piece sheep-file)
  (unless (car (aref *endgames* n-piece))
    (setf (car (aref *endgames* n-piece))
          (static-vectors:make-static-vector (max-state n-piece) :element-type 'fate)))
  (with-open-file (in sheep-file :element-type 'fate)
    (read-sequence (car (aref *endgames* n-piece)) in))
  (format t "Reading ~a pieces wolf-to-move from ~a.~%" n-piece wolf-file)
  (unless (cdr (aref *endgames* n-piece))
    (setf (cdr (aref *endgames* n-piece))
          (static-vectors:make-static-vector (max-state n-piece) :element-type 'fate)))
  (with-open-file (in wolf-file :element-type 'fate)
    (read-sequence (cdr (aref *endgames* n-piece)) in))
  t)

(defun save-endgames (n-piece sheep-file wolf-file)
  (format t "Writing ~a pieces sheep-to-move from ~a.~%" n-piece sheep-file)
  (with-open-file (out sheep-file :direction :output :element-type 'fate)
    (write-sequence (car (aref *endgames* n-piece)) out))
  (format t "Writing ~a pieces wolf-to-move from ~a.~%" n-piece wolf-file)
  (with-open-file (out wolf-file :direction :output :element-type 'fate)
    (write-sequence (cdr (aref *endgames* n-piece)) out))
  t)

(defun unload-endgames (&optional (n-piece t))
  (flet ((unload (i)
           (let ((p (aref *endgames* i)))
             (when (car p)
               (format t "Unloading ~a pieces sheep-to-move table~%" i)
               (static-vectors:free-static-vector (car p))
               (rplaca p nil))
             (when (cdr p)
               (format t "Unloading ~a pieces wolf-to-move table~%" i)
               (static-vectors:free-static-vector (cdr p))
               (rplacd p nil))
             nil)))
    (if (eq n-piece t)
        (iter (for i from 0 below (length *endgames*))
          (unload i))
        (unload n-piece))))

#+nil (init-tablebase *endgames*)
#+nil (save-endgames "~/playground/wolf-chess-10s.dtm" "~/playground/wolf-chess-10w.dtm")
