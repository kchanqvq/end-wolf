(in-package #:end-wolf)

(deftype fate () '(signed-byte 8))

(defconstant +wolf-m1+ 127)
(defconstant +sheep-m1+ -128)

(defconstant +max-n-pieces+ 10)

(defvar *worklist-threshold* 10000000)

;; non inclusive
(defun max-state (max-n-pieces)
  (ash (1+ (max-wolf-index max-n-pieces)) 25))

(deftype tablebase () `(simple-array fate (,(max-state +max-n-pieces+))))

(setq *print-length* 1000)

(defmacro do-states ((state-var max-n-piece) (&rest bindings) &body body)
  `(let ((results nil)
         (n-seg (/ (max-state ,max-n-piece) 256))
         (channel (lparallel:make-channel)))
     (declare (state n-seg))
     (dotimes (i 256)
       (lparallel:submit-task
        channel
        (lambda (start)
          (declare (state start))
          (let ,bindings
            (dotimes (i n-seg)
              (let ((,state-var (+ start i)))
                (declare (state i ,state-var))
                ,@body))
            (or (list ,@(mapcar #'car bindings)) t)))
        (* i n-seg)))
     (unwind-protect
          (iter (for last-progress = (length results))
            (while (< last-progress 256))
            (sleep 1)
            (iter (for r = (lparallel:try-receive-result channel))
              (while r)
              (push r results))
            (unless (= last-progress (length results))
              (format t "~,2f% " (/ (* 100 (length results)) 256)))
            (finally (return results)))
       (lparallel:kill-tasks :default))))

(defun init-tablebase (tablebase)
  (format t "~&Init.~%")
  (do-states (state +max-n-pieces+) ()
    (declare (optimize speed)
             (type tablebase tablebase))
    (let ((n-pieces (logcount (ldb (byte 25 0) state))))
      (when (= n-pieces 6)
        (when (<= (ldb (byte 10 25) state) (max-wolf-index 6))
          (setf (aref tablebase state) +wolf-m1+))))))

(defun tablebase-summary (tablebase n-piece)
  (check-type tablebase tablebase)
  (sb-thread:barrier (:memory))
  (let* ((max-wolf-index (max-wolf-index n-piece))
         (results
           (do-states (state n-piece)
               ((total 0)
                (sheep 0)
                (sheep-m-max 0)
                (wolf 0)
                (wolf-m-max 0)
                (unknown 0))
             (declare (optimize speed)
                      (type tablebase tablebase)
                      (type bitpos n-piece)
                      (type (unsigned-byte 10) max-wolf-index)
                      (type fixnum total sheep wolf unknown sheep-m-max wolf-m-max))
             (when (= (logcount (ldb (byte 25 0) state)) n-piece)
               (when (<= (ldb (byte 10 25) state) max-wolf-index)
                 (let ((fate (aref tablebase state)))
                   (case (signum fate)
                     (1 (incf total) (incf wolf)
                      (setq wolf-m-max (max wolf-m-max (1+ (- +wolf-m1+ fate)))))
                     (0 (incf total) (incf unknown))
                     (-1 (incf total) (incf sheep)
                      (setq sheep-m-max (max sheep-m-max (1+ (- fate +sheep-m1+)))))))))))
         (total (reduce #'+ results :key #'first))
         (sheep (reduce #'+ results :key #'second))
         (sheep-m-max (reduce #'max results :key #'third))
         (wolf (reduce #'+ results :key #'fourth))
         (wolf-m-max (reduce #'max results :key #'fifth))
         (unknown (reduce #'+ results :key #'sixth)))
    (format t "~&total valid: ~a~%" total)
    (format t "sheep: ~a (~,2f%), max mate in ~a~%" sheep (/ (* 100 sheep) total) sheep-m-max)
    (format t "wolf: ~a (~,2f%), max mate in ~a~%" wolf (/ (* 100 wolf) total) wolf-m-max)
    (format t "unknown: ~a (~,2f%)~%" unknown (/ (* 100 unknown) total))
    unknown))

(defun wolf-forward-scan (pair n-piece)
  (sb-thread:barrier (:memory))
  (let ((sheep (car pair))
        (wolf (cdr pair))
        (max-wolf-index (max-wolf-index n-piece)))
    (declare (type tablebase sheep wolf)
             (type bitpos n-piece)
             (type (unsigned-byte 10) max-wolf-index))
    (format t "~&Scan, wolf move, ~a pieces.~%" n-piece)
    (do-states (state n-piece) ()
      (declare (optimize speed))
      (when (= (logcount (ldb (byte 25 0) state)) n-piece)
        (when (<= (ldb (byte 10 25) state) max-wolf-index)
          (when (zerop (aref wolf state))
            (let ((fate +sheep-m1+))
              (declare (type fate fate))
              (wolf-forward state
                            (lambda (next-state)
                              (declare (type state next-state))
                              (let ((next-fate (aref sheep next-state)))
                                (setq fate (max fate (if (> next-fate 1) (1- next-fate) next-fate))))))
              (setf (aref wolf state) fate))))))))

(defun sheep-forward-scan (pair n-piece)
  (sb-thread:barrier (:memory))
  (let ((sheep (car pair))
        (wolf (cdr pair))
        (max-wolf-index (max-wolf-index n-piece)))
    (declare (type tablebase sheep wolf)
             (type bitpos n-piece)
             (type (unsigned-byte 10) max-wolf-index))
    (format t "~&Scan, sheep move, ~a pieces.~%" n-piece)
    (let ((results
            (do-states (state n-piece) ((delta 0))
              (declare (optimize speed) (fixnum delta))
              (when (= (logcount (ldb (byte 25 0) state)) n-piece)
                (when (<= (ldb (byte 10 25) state) max-wolf-index)
                  (when (zerop (aref sheep state))
                    (let ((fate +wolf-m1+))
                      (declare (type fate fate))
                      (sheep-forward state
                                     (lambda (next-state)
                                       (declare (type state next-state))
                                       (let ((next-fate (aref wolf next-state)))
                                         (setq fate (min fate (if (< next-fate -1) (1+ next-fate) next-fate))))))
                      (unless (zerop fate) (incf delta))
                      (setf (aref sheep state) fate))))))))
      (reduce #'+ results :key #'car))))

(defun wolf-forward-scan-create-worklist (pair n-piece)
  (sb-thread:barrier (:memory))
  (let ((sheep (car pair))
        (wolf (cdr pair))
        (max-wolf-index (max-wolf-index n-piece)))
    (declare (type tablebase sheep wolf)
             (type bitpos n-piece)
             (type (unsigned-byte 10) max-wolf-index))
    (format t "~&Scan create worklist, wolf move, ~a pieces.~%" n-piece)
    (let ((results
            (do-states (state n-piece) ((worklist))
              (declare (optimize speed))
              (when (= (logcount (ldb (byte 25 0) state)) n-piece)
                (when (<= (ldb (byte 10 25) state) max-wolf-index)
                  (when (zerop (aref wolf state))
                    (let ((fate +sheep-m1+))
                      (declare (type fate fate))
                      (wolf-forward state
                                    (lambda (next-state)
                                      (declare (type state next-state))
                                      (let ((next-fate (aref sheep next-state)))
                                        (setq fate (max fate (if (> next-fate 1) (1- next-fate) next-fate))))))
                      (unless (zerop fate)
                        (sheep-backward state
                                        (lambda (prev-state)
                                          (push prev-state worklist))))
                      (setf (aref wolf state) fate))))))))
      (sort-worklist (mapcan #'car results)))))

(defun parallel-sort (list)
  #+nil (let ((segments (lparallel:pmapcar (lambda (l) (sort l #'<)) (chop-worklist list 8))))
          (lparallel:preduce (lambda (a b) (merge 'list a b #'<)) segments))
  (let ((segments (mapcar (lambda (l) (lparallel:future (sort l #'<)))
                          (chop-worklist list 8))))
    (if (cdr segments)
        (lparallel:force
         (reduce (lambda (a b)
                   (lparallel:future
                     (merge 'list (lparallel:force a) (lparallel:force b) #'<)))
                 segments))
        (car segments))))

(defun sort-worklist (worklist)
  (setq worklist (parallel-sort worklist))
  (do ((tail worklist))
      ((null (cdr tail)))
    (if (= (car tail) (cadr tail))
        (rplacd tail (cddr tail))
        (setq tail (cdr tail))))
  worklist)

(defun chop-worklist (worklist n)
  (let ((m (max 1000 (ceiling (length worklist) n)))
        (results))
    (do ((tail (cons nil worklist))
         (i 0 (1+ i)))
        ((null tail) (remove-if #'null results))
      (if (zerop (mod i m))
          (let ((next (cdr tail)))
            (push next results)
            (rplacd tail nil)
            (setq tail next))
          (setq tail (cdr tail))))))

(defmacro do-worklist ((state-var worklist) (&rest bindings) &body body)
  `(let ((results nil)
         (works (chop-worklist ,worklist 256))
         (channel (lparallel:make-channel)))
     (dolist (w works)
       (lparallel:submit-task
        channel
        (lambda (%worklist)
          (let ,bindings
            (dolist (,state-var %worklist)
              (declare (state ,state-var))
              ,@body)
            (or (list ,@(mapcar #'car bindings)) t)))
        w))
     (unwind-protect
          (iter (for last-progress = (length results))
            (while (< last-progress (length works)))
            (sleep .2)
            (iter (for r = (lparallel:try-receive-result channel))
              (while r)
              (push r results))
            (unless (= last-progress (length results))
              (format t "~,2f% " (/ (* 100 (length results)) (length works))))
            (finally (return results)))
       (lparallel:kill-tasks :default))))

(defun sheep-forward-scan-use-worklist (pair worklist)
  (sb-thread:barrier (:memory))
  (let ((sheep (car pair))
        (wolf (cdr pair)))
    (declare (type tablebase sheep wolf))
    (format t "~&Worklist, sheep move.~%")
    (let ((results
            (do-worklist (state worklist) ((worklist))
              (declare (optimize speed))
              (when (zerop (aref sheep state))
                (let ((fate +wolf-m1+))
                  (declare (type fate fate))
                  (sheep-forward state
                                 (lambda (next-state)
                                   (declare (type state next-state))
                                   (let ((next-fate (aref wolf next-state)))
                                     (setq fate (min fate (if (< next-fate -1) (1+ next-fate) next-fate))))))
                  (unless (zerop fate)
                    (wolf-move-backward state
                                        (lambda (prev-state)
                                          (push prev-state worklist))))
                  (setf (aref sheep state) fate))))))
      (sort-worklist (mapcan #'car results)))))

(defun wolf-forward-scan-use-worklist (pair worklist)
  (sb-thread:barrier (:memory))
  (let ((sheep (car pair))
        (wolf (cdr pair)))
    (declare (type tablebase sheep wolf))
    (format t "~&Worklist, wolf move.~%")
    (let ((results
            (do-worklist (state worklist) ((worklist))
              (declare (optimize speed))
              (let ((fate +sheep-m1+))
                (declare (type fate fate))
                (wolf-forward state
                              (lambda (next-state)
                                (declare (type state next-state))
                                (let ((next-fate (aref sheep next-state)))
                                  (setq fate (max fate (if (> next-fate 1) (1- next-fate) next-fate))))))
                (unless (zerop fate)
                  (sheep-backward state
                                  (lambda (prev-state)
                                    (push prev-state worklist))))
                (setf (aref wolf state) fate)))))
      (sort-worklist (mapcan #'car results)))))

(defvar *endgames*)

(defun init ()
  (unless (boundp '*endgames*)
    (setq *endgames*
          (cons (static-vectors:make-static-vector (max-state +max-n-pieces+)
                                                   :initial-element 0
                                                   :element-type 'fate)
                (static-vectors:make-static-vector (max-state +max-n-pieces+)
                                                   :initial-element 0
                                                   :element-type 'fate))))
  (init-tablebase (car *endgames*))
  (setf (subseq (cdr *endgames*) 0) (car *endgames*))
  t)

(defun run (n-iter n-piece)
  (assert (<= 7 n-piece +max-n-pieces+))
  (iter (repeat n-iter)
    (wolf-forward-scan *endgames* n-piece)
    (let ((delta (sheep-forward-scan *endgames* n-piece)))
      (tablebase-summary (car *endgames*) n-piece)
      (format t "~&state change: ~a~%" delta)
      (cond ((zerop delta)
             (format t "~&===Done===~%")
             (return-from run))
            ((< delta *worklist-threshold*)
             (format t "~&===Switch to worklist===~%")
             (format t "use ~a worklist iterations~%" (* n-iter 10))
             (run-worklist (* n-iter 10) n-piece)
             (return-from run))))))

(defun run-worklist (n-iter n-piece)
  (assert (<= 7 n-piece +max-n-pieces+))
  (iter (with processed = 0)
    (for i below n-iter)
    (for worklist
         initially (wolf-forward-scan-create-worklist *endgames* n-piece)
         then (wolf-forward-scan-use-worklist *endgames* worklist))
    (while worklist)
    (setq worklist (sheep-forward-scan-use-worklist *endgames* worklist))
    (let ((s (length worklist)))
      (format t "~&worklist size: ~a~%" s)
      (when (> (floor (+ s processed) 1000000)
               (floor processed 1000000))
        (tablebase-summary (car *endgames*) n-piece)))
    (while worklist))
  (format t "~&===Done===~%"))

(defun load-endgames (sheep-file wolf-file)
  (unless (boundp '*endgames*)
    (setq *endgames*
          (cons (static-vectors:make-static-vector (max-state +max-n-pieces+)
                                                   :initial-element 0
                                                   :element-type 'fate)
                (static-vectors:make-static-vector (max-state +max-n-pieces+)
                                                   :initial-element 0
                                                   :element-type 'fate))))
  (with-open-file (in sheep-file :element-type 'fate)
    (read-sequence (car *endgames*) in))
  (with-open-file (in wolf-file :element-type 'fate)
    (read-sequence (cdr *endgames*) in)))

(defun save-endgames (sheep-file wolf-file)
  (with-open-file (out sheep-file :direction :output :element-type 'fate)
    (write-sequence (car *endgames*) out))
  (with-open-file (out wolf-file :direction :output :element-type 'fate)
    (write-sequence (cdr *endgames*) out)))

(defun unload-endgames ()
  (let ((e *endgames*))
    (makunbound '*endgames*)
    (static-vectors:free-static-vector (car e))
    (setf (car e) nil)
    (static-vectors:free-static-vector (cdr e))
    (setf (cdr e) nil)))

#+nil (init-tablebase *endgames*)
#+nil (save-endgames "~/playground/wolf-chess-10s.dtm" "~/playground/wolf-chess-10w.dtm")
